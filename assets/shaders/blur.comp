#version 430 
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D image;

uniform int offset;
uniform int amount;
uniform float freq;

// int kernel[] = { 1, 2, 1 };
int kernel[] = { 3, 1, 4, 1, 3 };
// int kernel[] = { 1, 2, 4, 8, 4, 2, 1 };
/* int kernel[] = { 1, 2, 4, 8, 16, 8, 4, 2, 1 }; */
/* int kernel[] = { 1, 2, 4, 8, 16, 32, 16, 8, 4, 2, 1 }; */
/* int kernel[] = { 16, 2, 3, 4, 5, 6, 5, 4, 3, 2, 16 }; */
/* int kernel[] = {16, 2, 1, 2, 16}; */
/* int kernelWidth = (ARRAY_SIZE(kernel) - 1) / 2; */

void main()
{
	ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

	int l = kernel.length();
	int width = int(gl_NumWorkGroups.x);
	int height = int(gl_NumWorkGroups.y);

	float avgR = 0;
	float avgG = 0;
	float avgB = 0;
	int minX = (coords.x - l < 0) ? 0 : coords.x - l;
	int maxX = (coords.x + l > width - 1) ? width - 1 : coords.x + l;
	int divAmount = 0;
	int kernelIndex = 0;
	for(int i = minX; i < maxX; i++) {
		vec4 pixel = imageLoad(image, ivec2(i, coords.y));
		avgR += pixel.r * kernel[kernelIndex];
		avgG += pixel.g * kernel[kernelIndex];
		avgB += pixel.b * kernel[kernelIndex];
		divAmount += kernel[kernelIndex];
		kernelIndex++;
	}

	int minY = (coords.y - l < 0) ? 0 : coords.y - l;
	int maxY = (coords.y + l > height - 1) ? height - 1 : coords.y + l;
	kernelIndex = 0;
	for(int i = minY; i < maxY; i++) {
		vec4 pixel = imageLoad(image, ivec2(coords.x, i));
		avgR += pixel.r * kernel[kernelIndex];
		avgG += pixel.g * kernel[kernelIndex];
		avgB += pixel.b * kernel[kernelIndex];
		divAmount += kernel[kernelIndex];
		kernelIndex++;
	}


	/* vec4 pixel = imageLoad(image, coords); */
	vec4 result = vec4(avgR / divAmount, avgG / divAmount, avgB / divAmount, 1.0);
	imageStore(image, coords, result);
}
