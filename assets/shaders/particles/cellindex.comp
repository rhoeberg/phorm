/* #version 430  */
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

/* #define WORK_GROUP_SIZE 32 */

// TODO (rhoe) this should probably be a uniform?
#define H 1 // radius from which particle can affect each other

/* #define TOTAL_GRID_CELL_COUNT 1024 // THIS NEEDS TO BE SIMILAR TO TOTAL GRID CELL COUNT IN C++ */

// TODO (rhoe) could be an optimization to store pos and vel seperatly
struct Particle {
	vec4 pos;
	vec4 vel;
};

// std140 helps remove the problem of memory layout issues
layout(binding=0) buffer particleBuffer
{
	Particle particles[]; 
};

/* layout(std140, binding=1) buffer indexBuffer */
layout(binding=1) buffer indexBuffer
{
	uint particleIndices[];
};

layout(binding=2) buffer cellBuffer
{
	uint cellIndices[];
};

uint GetFlatCellIndex(in ivec3 cellIndex)
{
  const uint p1 = 73856093; // some large primes
  const uint p2 = 19349663;
  const uint p3 = 83492791;
  uint n = p1 * cellIndex.x ^ p2*cellIndex.y ^ p3*cellIndex.z;
  n %= TOTAL_GRID_CELL_COUNT;
  return n;
}

// apparently we have to manually set the work group size
// we have to make sure this matches the c++ set size
layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

void main() {
	uint id = gl_GlobalInvocationID.x;

	uint particleIndex = particleIndices[id];
	Particle particle = particles[particleIndex];

	ivec3 cellIndex = ivec3(floor(particle.pos / H));
	uint flatCellIndex = GetFlatCellIndex(cellIndex);
	cellIndices[particleIndex] = flatCellIndex;

	/* particle.pos.y += particle.vel.x; */
	/* particles[particleIndex] = particle; */
}
